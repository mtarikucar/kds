import type { VoxelObject, VoxelPosition } from '../../types/voxel'

// Use native crypto.randomUUID() for generating unique IDs
const generateId = (): string => {
  if (typeof crypto !== 'undefined' && crypto.randomUUID) {
    return crypto.randomUUID()
  }
  // Fallback for older environments
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
    const r = (Math.random() * 16) | 0
    const v = c === 'x' ? r : (r & 0x3) | 0x8
    return v.toString(16)
  })
}

interface TableInfo {
  id: string
  position: VoxelPosition
  width: number
  depth: number
  rotation: number
}

export interface GeneratedChair extends VoxelObject {
  type: 'chair'
  linkedTableId: string
}

/**
 * Seat spacing configuration
 */
const CHAIR_CONFIG = {
  /** Minimum spacing between chair centers */
  minSpacing: 1.0,
  /** Ideal spacing between chair centers */
  idealSpacing: 1.2,
  /** Distance from table edge to chair center */
  distanceFromTable: 0.6,
  /** Chair dimensions */
  chairSize: { width: 0.8, depth: 0.8 },
}

/**
 * Calculate chair positions along an edge
 */
function calculateEdgeChairs(
  edgeStart: VoxelPosition,
  edgeEnd: VoxelPosition,
  facingDirection: number, // Rotation to face the table
  tableId: string,
  tableCenter: VoxelPosition
): GeneratedChair[] {
  const chairs: GeneratedChair[] = []

  // Calculate edge length
  const dx = edgeEnd.x - edgeStart.x
  const dz = edgeEnd.z - edgeStart.z
  const edgeLength = Math.sqrt(dx * dx + dz * dz)

  // Calculate how many chairs fit
  const numChairs = Math.max(1, Math.floor(edgeLength / CHAIR_CONFIG.idealSpacing))

  // Distribute chairs evenly along the edge
  for (let i = 0; i < numChairs; i++) {
    const t = numChairs === 1 ? 0.5 : i / (numChairs - 1)
    const x = edgeStart.x + dx * t
    const z = edgeStart.z + dz * t

    // Offset chair away from table
    const dirX = x - tableCenter.x
    const dirZ = z - tableCenter.z
    const dist = Math.sqrt(dirX * dirX + dirZ * dirZ)
    const offsetX = dist > 0 ? (dirX / dist) * CHAIR_CONFIG.distanceFromTable : 0
    const offsetZ = dist > 0 ? (dirZ / dist) * CHAIR_CONFIG.distanceFromTable : 0

    chairs.push({
      id: generateId(),
      type: 'chair',
      position: {
        x: x + offsetX - CHAIR_CONFIG.chairSize.width / 2,
        y: 0,
        z: z + offsetZ - CHAIR_CONFIG.chairSize.depth / 2,
      },
      rotation: { y: facingDirection },
      linkedTableId: tableId,
      metadata: {
        width: CHAIR_CONFIG.chairSize.width,
        depth: CHAIR_CONFIG.chairSize.depth,
        height: 1,
        autoGenerated: true,
      },
    })
  }

  return chairs
}

/**
 * Generate chairs around a table based on its size
 */
export function generateChairsForTable(table: TableInfo): GeneratedChair[] {
  const { id, position, width, depth, rotation } = table
  const chairs: GeneratedChair[] = []

  // Table center
  const centerX = position.x + width / 2
  const centerZ = position.z + depth / 2
  const tableCenter: VoxelPosition = { x: centerX, y: 0, z: centerZ }

  // Apply rotation transform to edge calculations
  const rad = (rotation * Math.PI) / 180

  // Define edges (before rotation transform)
  // North edge (front of table, chairs face toward table)
  if (depth >= CHAIR_CONFIG.minSpacing) {
    const northChairs = calculateEdgeChairs(
      { x: position.x + 0.3, y: 0, z: position.z - CHAIR_CONFIG.distanceFromTable },
      { x: position.x + width - 0.3, y: 0, z: position.z - CHAIR_CONFIG.distanceFromTable },
      0, // Face toward table (south)
      id,
      tableCenter
    )
    chairs.push(...northChairs)
  }

  // South edge (back of table, chairs face toward table)
  if (depth >= CHAIR_CONFIG.minSpacing) {
    const southChairs = calculateEdgeChairs(
      { x: position.x + 0.3, y: 0, z: position.z + depth + CHAIR_CONFIG.distanceFromTable },
      { x: position.x + width - 0.3, y: 0, z: position.z + depth + CHAIR_CONFIG.distanceFromTable },
      180, // Face toward table (north)
      id,
      tableCenter
    )
    chairs.push(...southChairs)
  }

  // For larger tables, add chairs on east/west sides
  if (width >= 2 && depth >= 2) {
    // East edge
    const eastChairs = calculateEdgeChairs(
      { x: position.x + width + CHAIR_CONFIG.distanceFromTable, y: 0, z: position.z + 0.3 },
      { x: position.x + width + CHAIR_CONFIG.distanceFromTable, y: 0, z: position.z + depth - 0.3 },
      90, // Face toward table (west)
      id,
      tableCenter
    )
    chairs.push(...eastChairs)

    // West edge
    const westChairs = calculateEdgeChairs(
      { x: position.x - CHAIR_CONFIG.distanceFromTable, y: 0, z: position.z + 0.3 },
      { x: position.x - CHAIR_CONFIG.distanceFromTable, y: 0, z: position.z + depth - 0.3 },
      270, // Face toward table (east)
      id,
      tableCenter
    )
    chairs.push(...westChairs)
  }

  // Apply table rotation to all chairs
  if (rotation !== 0) {
    return chairs.map((chair) => {
      const relX = chair.position.x - centerX
      const relZ = chair.position.z - centerZ
      const rotatedX = relX * Math.cos(rad) - relZ * Math.sin(rad)
      const rotatedZ = relX * Math.sin(rad) + relZ * Math.cos(rad)

      return {
        ...chair,
        position: {
          x: rotatedX + centerX,
          y: chair.position.y,
          z: rotatedZ + centerZ,
        },
        rotation: {
          y: (chair.rotation.y + rotation) % 360,
        },
      }
    })
  }

  return chairs
}

/**
 * Generate chairs for all tables in a layout
 */
export function generateAllChairs(
  tables: VoxelObject[],
  existingChairs: VoxelObject[]
): GeneratedChair[] {
  const allChairs: GeneratedChair[] = []

  for (const table of tables) {
    if (table.type !== 'table') continue

    // Check if this table already has chairs
    const hasChairs = existingChairs.some(
      (chair) => chair.linkedTableId === table.id
    )
    if (hasChairs) continue

    const tableInfo: TableInfo = {
      id: table.id,
      position: table.position,
      width: (table.metadata?.width as number) ?? 2,
      depth: (table.metadata?.depth as number) ?? 2,
      rotation: table.rotation.y,
    }

    const chairs = generateChairsForTable(tableInfo)
    allChairs.push(...chairs)
  }

  return allChairs
}

/**
 * Calculate recommended capacity based on table size
 */
export function calculateTableCapacity(width: number, depth: number): number {
  // Calculate based on perimeter chairs
  const longSideChairs = Math.max(1, Math.floor(Math.max(width, depth) / CHAIR_CONFIG.idealSpacing))
  const shortSideChairs = Math.max(width, depth) >= 2
    ? Math.max(1, Math.floor(Math.min(width, depth) / CHAIR_CONFIG.idealSpacing))
    : 0

  // 2 long sides + 2 short sides (if applicable)
  return longSideChairs * 2 + shortSideChairs * 2
}
