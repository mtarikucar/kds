name: Release Deployment

on:
  push:
    tags:
      - 'v*.*.*'  # Matches v1.0.0, v2.1.3, etc.
  workflow_dispatch:
    inputs:
      tag:
        description: 'Release tag (e.g., v1.0.0)'
        required: true
        type: string

permissions:
  contents: write  # Required for creating releases
  pull-requests: read

env:
  NODE_VERSION: '18.x'
  SERVER_HOST: '38.242.233.166'

jobs:
  # Quick health check before starting expensive operations
  pre-check:
    name: Pre-deployment Health Check
    runs-on: ubuntu-latest
    steps:
      - name: Check production API availability
        run: |
          echo "üîç Checking if production API is accessible..."
          if ! curl -sf https://hummytummy.com/api/health > /dev/null; then
            echo "‚ö†Ô∏è Warning: API health check failed, but continuing..."
          else
            echo "‚úÖ Production API is healthy"
          fi

      - name: Check production frontend availability
        run: |
          echo "üîç Checking if production frontend is accessible..."
          if ! curl -sf https://hummytummy.com > /dev/null; then
            echo "‚ö†Ô∏è Warning: Frontend check failed, but continuing..."
          else
            echo "‚úÖ Production frontend is accessible"
          fi

      - name: Setup SSH (for connection test)
        env:
          SSH_PRIVATE_KEY_BASE64: ${{ secrets.SSH_PRIVATE_KEY_BASE64 }}
          SSH_KNOWN_HOSTS: ${{ secrets.SSH_KNOWN_HOSTS }}
        run: |
          mkdir -p ~/.ssh
          echo "$SSH_PRIVATE_KEY_BASE64" | base64 -d > ~/.ssh/id_ed25519
          chmod 600 ~/.ssh/id_ed25519
          echo "$SSH_KNOWN_HOSTS" > ~/.ssh/known_hosts
          chmod 644 ~/.ssh/known_hosts

      - name: Validate SSH key format
        run: |
          echo "üîë Validating SSH key format..."
          if ! ssh-keygen -l -f ~/.ssh/id_ed25519 2>/dev/null; then
            echo "‚ùå SSH key validation failed!"
            echo ""
            echo "The SSH_PRIVATE_KEY secret is not in the correct format."
            echo "Please check .github/SECRETS_SETUP.md for instructions."
            echo ""
            echo "Common issues:"
            echo "  - Key must include '-----BEGIN OPENSSH PRIVATE KEY-----' header"
            echo "  - Key must include '-----END OPENSSH PRIVATE KEY-----' footer"
            echo "  - All lines must be copied exactly as-is"
            echo "  - No extra spaces or newlines should be added"
            exit 1
          fi
          echo "‚úÖ SSH key format is valid"

      - name: Test SSH connection to production server
        run: |
          echo "üîå Testing SSH connection to ${{ env.SERVER_HOST }}..."
          if ! ssh -o ConnectTimeout=10 -o BatchMode=yes -o StrictHostKeyChecking=yes root@${{ env.SERVER_HOST }} "echo 'SSH connection successful'" 2>&1; then
            echo ""
            echo "‚ùå SSH connection to production server failed!"
            echo ""
            echo "Please verify:"
            echo "  1. SSH_PRIVATE_KEY secret is correctly set (see .github/SECRETS_SETUP.md)"
            echo "  2. SSH_KNOWN_HOSTS secret is correctly set (no # comment lines)"
            echo "  3. Server ${{ env.SERVER_HOST }} is accessible"
            echo "  4. Public key is in server's ~/.ssh/authorized_keys"
            echo ""
            echo "To fix SSH_KNOWN_HOSTS, run locally:"
            echo "  ssh-keyscan -H ${{ env.SERVER_HOST }}"
            echo "  (Copy only lines starting with |1|, exclude lines with #)"
            exit 1
          fi
          echo "‚úÖ SSH connection test passed"

  # Build and deploy to production using Blue-Green strategy
  deploy-production:
    name: Build and Deploy to Production
    runs-on: ubuntu-latest
    needs: pre-check
    environment: production

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Get version
        id: version
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "VERSION=${{ github.event.inputs.tag }}" >> $GITHUB_OUTPUT
          else
            echo "VERSION=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT
          fi

      - name: Build backend image
        run: |
          docker build \
            --target production \
            --tag kds-backend:${{ steps.version.outputs.VERSION }} \
            --tag kds-backend:latest \
            ./backend

      - name: Build frontend image
        env:
          VITE_GOOGLE_CLIENT_ID: ${{ secrets.VITE_GOOGLE_CLIENT_ID }}
        run: |
          docker build \
            --target production \
            --build-arg VITE_API_URL=https://hummytummy.com/api \
            --build-arg VITE_API_BASE_URL=https://hummytummy.com \
            --build-arg VITE_SOCKET_URL=https://hummytummy.com \
            --build-arg VITE_WS_URL=wss://hummytummy.com \
            --build-arg "VITE_GOOGLE_CLIENT_ID=${VITE_GOOGLE_CLIENT_ID}" \
            --build-arg VITE_APP_VERSION=${{ steps.version.outputs.VERSION }} \
            --build-arg VITE_BUILD_TIME=$(date -u +"%Y-%m-%dT%H:%M:%SZ") \
            --build-arg VITE_COMMIT_SHA=$(git rev-parse --short HEAD) \
            --tag kds-frontend:${{ steps.version.outputs.VERSION }} \
            --tag kds-frontend:latest \
            ./frontend

      - name: Build landing image
        run: |
          docker build \
            --build-arg NEXT_PUBLIC_API_URL=https://hummytummy.com/api \
            --build-arg NEXT_PUBLIC_SITE_URL=https://hummytummy.com \
            --tag kds-landing:${{ steps.version.outputs.VERSION }} \
            --tag kds-landing:latest \
            ./landing

      - name: Save Docker images
        run: |
          docker save kds-backend:${{ steps.version.outputs.VERSION }} | gzip > backend-${{ steps.version.outputs.VERSION }}.tar.gz
          docker save kds-frontend:${{ steps.version.outputs.VERSION }} | gzip > frontend-${{ steps.version.outputs.VERSION }}.tar.gz
          docker save kds-landing:${{ steps.version.outputs.VERSION }} | gzip > landing-${{ steps.version.outputs.VERSION }}.tar.gz

      - name: Setup SSH
        env:
          SSH_PRIVATE_KEY_BASE64: ${{ secrets.SSH_PRIVATE_KEY_BASE64 }}
          SSH_KNOWN_HOSTS: ${{ secrets.SSH_KNOWN_HOSTS }}
        run: |
          mkdir -p ~/.ssh
          echo "$SSH_PRIVATE_KEY_BASE64" | base64 -d > ~/.ssh/id_ed25519
          chmod 600 ~/.ssh/id_ed25519
          echo "$SSH_KNOWN_HOSTS" > ~/.ssh/known_hosts
          chmod 644 ~/.ssh/known_hosts

      - name: Create database backup
        run: |
          ssh root@${{ env.SERVER_HOST }} << 'EOF'
            cd /root/kds
            ./scripts/backup-database.sh
          EOF

      - name: Transfer Docker images
        run: |
          scp backend-${{ steps.version.outputs.VERSION }}.tar.gz root@${{ env.SERVER_HOST }}:/root/kds/
          scp frontend-${{ steps.version.outputs.VERSION }}.tar.gz root@${{ env.SERVER_HOST }}:/root/kds/
          scp landing-${{ steps.version.outputs.VERSION }}.tar.gz root@${{ env.SERVER_HOST }}:/root/kds/

      - name: Load Docker images on server
        run: |
          ssh root@${{ env.SERVER_HOST }} << EOF
            cd /root/kds
            docker load < backend-${{ steps.version.outputs.VERSION }}.tar.gz
            docker load < frontend-${{ steps.version.outputs.VERSION }}.tar.gz
            docker load < landing-${{ steps.version.outputs.VERSION }}.tar.gz
            rm -f backend-${{ steps.version.outputs.VERSION }}.tar.gz frontend-${{ steps.version.outputs.VERSION }}.tar.gz landing-${{ steps.version.outputs.VERSION }}.tar.gz
          EOF

      - name: Deploy with Blue-Green strategy
        id: deploy
        env:
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          JWT_REFRESH_SECRET: ${{ secrets.JWT_REFRESH_SECRET }}
          PAYTR_MERCHANT_ID: ${{ secrets.PAYTR_MERCHANT_ID }}
          PAYTR_MERCHANT_KEY: ${{ secrets.PAYTR_MERCHANT_KEY }}
          PAYTR_MERCHANT_SALT: ${{ secrets.PAYTR_MERCHANT_SALT }}
          IYZICO_API_KEY: ${{ secrets.IYZICO_API_KEY }}
          IYZICO_SECRET_KEY: ${{ secrets.IYZICO_SECRET_KEY }}
          EMAIL_HOST: ${{ secrets.EMAIL_HOST }}
          EMAIL_USER: ${{ secrets.EMAIL_USER }}
          EMAIL_PASSWORD: ${{ secrets.EMAIL_PASSWORD }}
          EMAIL_FROM: ${{ secrets.EMAIL_FROM }}
          GOOGLE_CLIENT_ID: ${{ secrets.GOOGLE_CLIENT_ID }}
          GOOGLE_CLIENT_SECRET: ${{ secrets.GOOGLE_CLIENT_SECRET }}
          DESKTOP_RELEASE_API_KEY: ${{ secrets.DESKTOP_RELEASE_API_KEY }}
        run: |
          ssh root@${{ env.SERVER_HOST }} << EOF
            cd /root/kds

            # Pull latest code
            git fetch --all --tags
            git checkout ${{ steps.version.outputs.VERSION }}

            # Create .env.production with all required variables
            cat > .env.production << ENVFILE
          # Production Environment Configuration
          # Auto-generated by GitHub Actions

          # Database
          POSTGRES_DB=restaurant_pos
          POSTGRES_USER=postgres
          POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
          DATABASE_URL=postgresql://postgres:${POSTGRES_PASSWORD}@postgres:5432/restaurant_pos?connection_limit=25&pool_timeout=10
          REDIS_URL=redis://redis:6379/0

          # JWT
          JWT_SECRET=${JWT_SECRET}
          JWT_EXPIRES_IN=7d
          JWT_REFRESH_SECRET=${JWT_REFRESH_SECRET}
          JWT_REFRESH_EXPIRES_IN=30d

          # CORS
          CORS_ORIGIN=https://hummytummy.com,http://tauri.localhost,tauri://localhost,https://tauri.localhost
          FRONTEND_URL=https://hummytummy.com

          # Iyzico Payment
          IYZICO_API_KEY=${IYZICO_API_KEY}
          IYZICO_SECRET_KEY=${IYZICO_SECRET_KEY}
          IYZICO_BASE_URL=https://api.iyzipay.com

          # PayTR Payment
          PAYTR_MERCHANT_ID=${PAYTR_MERCHANT_ID}
          PAYTR_MERCHANT_KEY=${PAYTR_MERCHANT_KEY}
          PAYTR_MERCHANT_SALT=${PAYTR_MERCHANT_SALT}
          PAYTR_BASE_URL=https://www.paytr.com
          PAYTR_TEST_MODE=false
          BACKEND_URL=https://hummytummy.com

          # Email (SMTP)
          EMAIL_HOST=${EMAIL_HOST}
          EMAIL_PORT=587
          EMAIL_SECURE=false
          EMAIL_USER=${EMAIL_USER}
          EMAIL_PASSWORD=${EMAIL_PASSWORD}
          EMAIL_FROM=${EMAIL_FROM}
          ADMIN_EMAIL=contact@hummytummy.com

          # Subscription
          DEFAULT_TRIAL_DAYS=14
          TRIAL_REMINDER_DAYS=3

          # Google OAuth
          GOOGLE_CLIENT_ID=${GOOGLE_CLIENT_ID}
          GOOGLE_CLIENT_SECRET=${GOOGLE_CLIENT_SECRET}

          # Frontend
          VITE_API_URL=https://hummytummy.com/api
          VITE_API_BASE_URL=https://hummytummy.com
          VITE_SOCKET_URL=https://hummytummy.com
          VITE_WS_URL=wss://hummytummy.com
          VITE_GOOGLE_CLIENT_ID=${GOOGLE_CLIENT_ID}

          # Desktop Release
          DESKTOP_RELEASE_API_KEY=${DESKTOP_RELEASE_API_KEY}
          ENVFILE

            # Run Blue-Green deployment
            ./scripts/blue-green-deploy.sh deploy

            if [ \$? -ne 0 ]; then
              echo "Deployment failed!"
              exit 1
            fi
          EOF

      - name: Run health checks
        run: |
          echo "Waiting for services to stabilize..."
          sleep 15

          # Check main API
          if ! curl -sf https://hummytummy.com/api/health > /dev/null; then
            echo "API health check failed!"
            exit 1
          fi

          # Check homepage
          if ! curl -sf https://hummytummy.com > /dev/null; then
            echo "Frontend health check failed!"
            exit 1
          fi

          echo "All health checks passed!"

      - name: Create GitHub Release
        if: success() && github.event_name == 'push'
        continue-on-error: true  # Don't fail deployment if release creation fails
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ steps.version.outputs.VERSION }}
          name: Release ${{ steps.version.outputs.VERSION }}
          body: |
            ## üöÄ Release ${{ steps.version.outputs.VERSION }}

            **Deployed at:** ${{ github.event.head_commit.timestamp }}
            **Commit:** ${{ github.sha }}
            **Environment:** https://hummytummy.com

            ### Deployment Strategy
            - ‚úÖ Blue-Green deployment
            - ‚úÖ Zero-downtime deployment
            - ‚úÖ Automatic health checks
            - ‚úÖ Database backup created

            ### Changes
            See commit history for details.
          draft: false
          prerelease: false

      - name: Notify success
        if: success()
        run: |
          echo "üéâ Production deployment successful!"
          echo "Version: ${{ steps.version.outputs.VERSION }}"
          echo "URL: https://hummytummy.com"

      - name: Rollback on failure
        if: failure() && steps.deploy.outcome == 'failure'
        run: |
          echo "‚ö†Ô∏è Deployment failed, initiating rollback..."
          ssh root@${{ env.SERVER_HOST }} << 'EOF'
            cd /root/kds
            ./scripts/blue-green-deploy.sh rollback
          EOF

      - name: Cleanup on failure
        if: failure()
        run: |
          echo "üßπ Cleaning up failed deployment..."
          ssh root@${{ env.SERVER_HOST }} << EOF
            cd /root/kds
            rm -f backend-${{ steps.version.outputs.VERSION }}.tar.gz
            rm -f frontend-${{ steps.version.outputs.VERSION }}.tar.gz
            rm -f landing-${{ steps.version.outputs.VERSION }}.tar.gz
          EOF

  # Post-deployment verification
  verify:
    name: Post-Deployment Verification
    runs-on: ubuntu-latest
    needs: deploy-production

    steps:
      - name: Comprehensive health check
        run: |
          echo "Running comprehensive health checks..."

          # API health
          echo "Checking API..."
          curl -sf https://hummytummy.com/api/health || exit 1

          # Frontend
          echo "Checking frontend..."
          curl -sf https://hummytummy.com || exit 1

          # SSL certificate
          echo "Checking SSL certificate..."
          echo | openssl s_client -servername hummytummy.com -connect hummytummy.com:443 2>/dev/null | \
            openssl x509 -noout -dates || exit 1

          echo "‚úÖ All verification checks passed!"

      - name: Performance check
        run: |
          echo "Checking response times..."

          start=$(date +%s%3N)
          curl -sf https://hummytummy.com/api/health > /dev/null
          end=$(date +%s%3N)

          response_time=$((end - start))
          echo "API response time: ${response_time}ms"

          if [ $response_time -gt 5000 ]; then
            echo "‚ö†Ô∏è Warning: Response time is high (${response_time}ms)"
          else
            echo "‚úÖ Response time is good (${response_time}ms)"
          fi
