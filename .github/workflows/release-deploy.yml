name: Release Deployment

on:
  push:
    tags:
      - 'v*.*.*'  # Matches v1.0.0, v2.1.3, etc.
  workflow_dispatch:
    inputs:
      tag:
        description: 'Release tag (e.g., v1.0.0)'
        required: true
        type: string

permissions:
  contents: write
  pull-requests: read

env:
  NODE_VERSION: '18.x'
  SERVER_HOST: '38.242.233.166'

jobs:
  # Quick health check before starting expensive operations
  pre-check:
    name: Pre-deployment Health Check
    runs-on: ubuntu-latest
    steps:
      - name: Check production API availability
        run: |
          echo "Checking if production API is accessible..."
          if ! curl -sf https://hummytummy.com/api/health > /dev/null; then
            echo "Warning: API health check failed, but continuing..."
          else
            echo "Production API is healthy"
          fi

      - name: Check production frontend availability
        run: |
          echo "Checking if production frontend is accessible..."
          if ! curl -sf https://hummytummy.com > /dev/null; then
            echo "Warning: Frontend check failed, but continuing..."
          else
            echo "Production frontend is accessible"
          fi

      - name: Setup SSH (for connection test)
        env:
          SSH_PRIVATE_KEY_BASE64: ${{ secrets.SSH_PRIVATE_KEY_BASE64 }}
          SSH_KNOWN_HOSTS: ${{ secrets.SSH_KNOWN_HOSTS }}
        run: |
          mkdir -p ~/.ssh
          echo "$SSH_PRIVATE_KEY_BASE64" | base64 -d > ~/.ssh/id_ed25519
          chmod 600 ~/.ssh/id_ed25519
          echo "$SSH_KNOWN_HOSTS" > ~/.ssh/known_hosts
          chmod 644 ~/.ssh/known_hosts

      - name: Validate SSH key format
        run: |
          echo "Validating SSH key format..."
          if ! ssh-keygen -l -f ~/.ssh/id_ed25519 2>/dev/null; then
            echo "SSH key validation failed!"
            echo "Please check .github/SECRETS_SETUP.md for instructions."
            exit 1
          fi
          echo "SSH key format is valid"

      - name: Test SSH connection to production server
        run: |
          echo "Testing SSH connection to ${{ env.SERVER_HOST }}..."
          if ! ssh -o ConnectTimeout=10 -o BatchMode=yes -o StrictHostKeyChecking=yes root@${{ env.SERVER_HOST }} "echo 'SSH connection successful'" 2>&1; then
            echo "SSH connection to production server failed!"
            exit 1
          fi
          echo "SSH connection test passed"

  # Build and deploy to production
  deploy-production:
    name: Build and Deploy to Production
    runs-on: ubuntu-latest
    needs: pre-check
    environment: production

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Get version
        id: version
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "VERSION=${{ github.event.inputs.tag }}" >> $GITHUB_OUTPUT
          else
            echo "VERSION=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT
          fi

      - name: Build backend image
        run: |
          docker build \
            --target production \
            --tag kds-backend:${{ steps.version.outputs.VERSION }} \
            --tag kds-backend:latest \
            ./backend

      - name: Build frontend image
        env:
          VITE_GOOGLE_CLIENT_ID: ${{ secrets.VITE_GOOGLE_CLIENT_ID }}
          SENTRY_AUTH_TOKEN: ${{ secrets.SENTRY_AUTH_TOKEN }}
          SENTRY_ORG: ${{ secrets.SENTRY_ORG }}
          SENTRY_PROJECT_FRONTEND: ${{ secrets.SENTRY_PROJECT_FRONTEND }}
        run: |
          docker build \
            --target production \
            --build-arg VITE_API_URL=https://hummytummy.com/api \
            --build-arg VITE_API_BASE_URL=https://hummytummy.com \
            --build-arg VITE_SOCKET_URL=https://hummytummy.com \
            --build-arg VITE_WS_URL=wss://hummytummy.com \
            --build-arg "VITE_GOOGLE_CLIENT_ID=${VITE_GOOGLE_CLIENT_ID}" \
            --build-arg VITE_APP_VERSION=${{ steps.version.outputs.VERSION }} \
            --build-arg VITE_BUILD_TIME=$(date -u +"%Y-%m-%dT%H:%M:%SZ") \
            --build-arg VITE_COMMIT_SHA=$(git rev-parse --short HEAD) \
            --build-arg SENTRY_AUTH_TOKEN="${SENTRY_AUTH_TOKEN}" \
            --build-arg SENTRY_ORG="${SENTRY_ORG}" \
            --build-arg SENTRY_PROJECT_FRONTEND="${SENTRY_PROJECT_FRONTEND}" \
            --tag kds-frontend:${{ steps.version.outputs.VERSION }} \
            --tag kds-frontend:latest \
            ./frontend

      - name: Build landing image
        env:
          SENTRY_AUTH_TOKEN: ${{ secrets.SENTRY_AUTH_TOKEN }}
          SENTRY_ORG: ${{ secrets.SENTRY_ORG }}
          SENTRY_PROJECT_LANDING: ${{ secrets.SENTRY_PROJECT_LANDING }}
        run: |
          docker build \
            --build-arg NEXT_PUBLIC_API_URL=https://hummytummy.com/api \
            --build-arg NEXT_PUBLIC_SITE_URL=https://hummytummy.com \
            --build-arg SENTRY_AUTH_TOKEN="${SENTRY_AUTH_TOKEN}" \
            --build-arg SENTRY_ORG="${SENTRY_ORG}" \
            --build-arg SENTRY_PROJECT="${SENTRY_PROJECT_LANDING}" \
            --tag kds-landing:${{ steps.version.outputs.VERSION }} \
            --tag kds-landing:latest \
            ./landing

      - name: Save Docker images
        run: |
          docker save kds-backend:${{ steps.version.outputs.VERSION }} | gzip > backend-${{ steps.version.outputs.VERSION }}.tar.gz
          docker save kds-frontend:${{ steps.version.outputs.VERSION }} | gzip > frontend-${{ steps.version.outputs.VERSION }}.tar.gz
          docker save kds-landing:${{ steps.version.outputs.VERSION }} | gzip > landing-${{ steps.version.outputs.VERSION }}.tar.gz

      - name: Setup SSH
        env:
          SSH_PRIVATE_KEY_BASE64: ${{ secrets.SSH_PRIVATE_KEY_BASE64 }}
          SSH_KNOWN_HOSTS: ${{ secrets.SSH_KNOWN_HOSTS }}
        run: |
          mkdir -p ~/.ssh
          echo "$SSH_PRIVATE_KEY_BASE64" | base64 -d > ~/.ssh/id_ed25519
          chmod 600 ~/.ssh/id_ed25519
          echo "$SSH_KNOWN_HOSTS" > ~/.ssh/known_hosts
          chmod 644 ~/.ssh/known_hosts

      - name: Transfer Docker images
        run: |
          scp backend-${{ steps.version.outputs.VERSION }}.tar.gz root@${{ env.SERVER_HOST }}:/root/kds/
          scp frontend-${{ steps.version.outputs.VERSION }}.tar.gz root@${{ env.SERVER_HOST }}:/root/kds/
          scp landing-${{ steps.version.outputs.VERSION }}.tar.gz root@${{ env.SERVER_HOST }}:/root/kds/

      - name: Deploy to production
        id: deploy
        env:
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          JWT_REFRESH_SECRET: ${{ secrets.JWT_REFRESH_SECRET }}
          PAYTR_MERCHANT_ID: ${{ secrets.PAYTR_MERCHANT_ID }}
          PAYTR_MERCHANT_KEY: ${{ secrets.PAYTR_MERCHANT_KEY }}
          PAYTR_MERCHANT_SALT: ${{ secrets.PAYTR_MERCHANT_SALT }}
          IYZICO_API_KEY: ${{ secrets.IYZICO_API_KEY }}
          IYZICO_SECRET_KEY: ${{ secrets.IYZICO_SECRET_KEY }}
          EMAIL_HOST: ${{ secrets.EMAIL_HOST }}
          EMAIL_USER: ${{ secrets.EMAIL_USER }}
          EMAIL_PASSWORD: ${{ secrets.EMAIL_PASSWORD }}
          EMAIL_FROM: ${{ secrets.EMAIL_FROM }}
          GOOGLE_CLIENT_ID: ${{ secrets.GOOGLE_CLIENT_ID }}
          GOOGLE_CLIENT_SECRET: ${{ secrets.GOOGLE_CLIENT_SECRET }}
          DESKTOP_RELEASE_API_KEY: ${{ secrets.DESKTOP_RELEASE_API_KEY }}
        run: |
          ssh root@${{ env.SERVER_HOST }} << EOF
            cd /root/kds

            # Pull latest code
            git fetch --all --tags
            git reset --hard HEAD
            git checkout ${{ steps.version.outputs.VERSION }}

            # Load Docker images
            echo "Loading Docker images..."
            docker load < backend-${{ steps.version.outputs.VERSION }}.tar.gz
            docker load < frontend-${{ steps.version.outputs.VERSION }}.tar.gz
            docker load < landing-${{ steps.version.outputs.VERSION }}.tar.gz

            # Tag images for deployment
            docker tag kds-backend:${{ steps.version.outputs.VERSION }} kds-backend:latest
            docker tag kds-frontend:${{ steps.version.outputs.VERSION }} kds-frontend:latest
            docker tag kds-landing:${{ steps.version.outputs.VERSION }} kds-landing:latest

            # Clean up tar files
            rm -f backend-${{ steps.version.outputs.VERSION }}.tar.gz
            rm -f frontend-${{ steps.version.outputs.VERSION }}.tar.gz
            rm -f landing-${{ steps.version.outputs.VERSION }}.tar.gz

            # Create .env.production
            cat > .env.production << ENVFILE
          # Production Environment Configuration
          # Auto-generated by GitHub Actions - ${{ steps.version.outputs.VERSION }}

          # Database
          POSTGRES_DB=restaurant_pos_prod
          POSTGRES_USER=postgres
          POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
          DATABASE_URL=postgresql://postgres:${POSTGRES_PASSWORD}@postgres:5432/restaurant_pos_prod?connection_limit=25&pool_timeout=10
          REDIS_URL=redis://redis:6379/0

          # JWT
          JWT_SECRET=${JWT_SECRET}
          JWT_EXPIRES_IN=7d
          JWT_REFRESH_SECRET=${JWT_REFRESH_SECRET}
          JWT_REFRESH_EXPIRES_IN=30d

          # CORS
          CORS_ORIGIN=https://hummytummy.com,http://tauri.localhost,tauri://localhost,https://tauri.localhost
          FRONTEND_URL=https://hummytummy.com

          # Iyzico Payment
          IYZICO_API_KEY=${IYZICO_API_KEY}
          IYZICO_SECRET_KEY=${IYZICO_SECRET_KEY}
          IYZICO_BASE_URL=https://api.iyzipay.com

          # PayTR Payment
          PAYTR_MERCHANT_ID=${PAYTR_MERCHANT_ID}
          PAYTR_MERCHANT_KEY=${PAYTR_MERCHANT_KEY}
          PAYTR_MERCHANT_SALT=${PAYTR_MERCHANT_SALT}
          PAYTR_BASE_URL=https://www.paytr.com
          PAYTR_TEST_MODE=false
          BACKEND_URL=https://hummytummy.com

          # Email (SMTP)
          EMAIL_HOST=${EMAIL_HOST}
          EMAIL_PORT=587
          EMAIL_SECURE=false
          EMAIL_USER=${EMAIL_USER}
          EMAIL_PASSWORD=${EMAIL_PASSWORD}
          EMAIL_FROM=${EMAIL_FROM}
          ADMIN_EMAIL=contact@hummytummy.com

          # Subscription
          DEFAULT_TRIAL_DAYS=14
          TRIAL_REMINDER_DAYS=3

          # Google OAuth
          GOOGLE_CLIENT_ID=${GOOGLE_CLIENT_ID}
          GOOGLE_CLIENT_SECRET=${GOOGLE_CLIENT_SECRET}

          # Frontend
          VITE_API_URL=https://hummytummy.com/api
          VITE_API_BASE_URL=https://hummytummy.com
          VITE_SOCKET_URL=https://hummytummy.com
          VITE_WS_URL=wss://hummytummy.com
          VITE_GOOGLE_CLIENT_ID=${GOOGLE_CLIENT_ID}

          # Desktop Release
          DESKTOP_RELEASE_API_KEY=${DESKTOP_RELEASE_API_KEY}
          ENVFILE

            # Run deployment
            ./scripts/deploy-production.sh deploy

            if [ \$? -ne 0 ]; then
              echo "Deployment failed!"
              exit 1
            fi
          EOF

      - name: Run health checks
        run: |
          echo "Waiting for services to stabilize..."
          sleep 15

          # Check main API
          if ! curl -sf https://hummytummy.com/api/health > /dev/null; then
            echo "API health check failed!"
            exit 1
          fi

          # Check homepage
          if ! curl -sf https://hummytummy.com > /dev/null; then
            echo "Frontend health check failed!"
            exit 1
          fi

          echo "All health checks passed!"

      - name: Create Sentry release
        if: success()
        env:
          SENTRY_AUTH_TOKEN: ${{ secrets.SENTRY_AUTH_TOKEN }}
          SENTRY_ORG: ${{ secrets.SENTRY_ORG }}
        run: |
          # Install sentry-cli
          curl -sL https://sentry.io/get-cli/ | bash

          VERSION="${{ steps.version.outputs.VERSION }}"

          # Create releases for all projects
          for PROJECT in "${{ secrets.SENTRY_PROJECT_BACKEND }}" "${{ secrets.SENTRY_PROJECT_FRONTEND }}" "${{ secrets.SENTRY_PROJECT_LANDING }}"; do
            if [ -n "$PROJECT" ]; then
              echo "Creating Sentry release for ${PROJECT}..."

              # Create release
              sentry-cli releases new "${PROJECT}@${VERSION}" --project "${PROJECT}" || true

              # Associate commits
              sentry-cli releases set-commits "${PROJECT}@${VERSION}" --auto --project "${PROJECT}" || true

              # Create deployment
              sentry-cli releases deploys "${PROJECT}@${VERSION}" new --env production --project "${PROJECT}" || true

              # Finalize release
              sentry-cli releases finalize "${PROJECT}@${VERSION}" --project "${PROJECT}" || true
            fi
          done

          echo "Sentry releases created successfully!"

      - name: Create GitHub Release
        if: success() && github.event_name == 'push'
        continue-on-error: true
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ steps.version.outputs.VERSION }}
          name: Release ${{ steps.version.outputs.VERSION }}
          body: |
            ## Release ${{ steps.version.outputs.VERSION }}

            **Deployed at:** ${{ github.event.head_commit.timestamp }}
            **Commit:** ${{ github.sha }}
            **Environment:** https://hummytummy.com

            ### Deployment
            - Database backup created
            - Migrations applied
            - Health checks passed

            ### Changes
            See commit history for details.
          draft: false
          prerelease: false

      - name: Notify success
        if: success()
        run: |
          echo "Production deployment successful!"
          echo "Version: ${{ steps.version.outputs.VERSION }}"
          echo "URL: https://hummytummy.com"

      - name: Rollback on failure
        if: failure() && steps.deploy.outcome == 'failure'
        run: |
          echo "Deployment failed, initiating rollback..."
          ssh root@${{ env.SERVER_HOST }} << 'EOF'
            cd /root/kds
            ./scripts/deploy-production.sh rollback
          EOF

      - name: Cleanup on failure
        if: failure()
        run: |
          echo "Cleaning up failed deployment..."
          ssh root@${{ env.SERVER_HOST }} << EOF
            cd /root/kds
            rm -f backend-${{ steps.version.outputs.VERSION }}.tar.gz
            rm -f frontend-${{ steps.version.outputs.VERSION }}.tar.gz
            rm -f landing-${{ steps.version.outputs.VERSION }}.tar.gz
          EOF

  # Post-deployment verification
  verify:
    name: Post-Deployment Verification
    runs-on: ubuntu-latest
    needs: deploy-production

    steps:
      - name: Comprehensive health check
        run: |
          echo "Running comprehensive health checks..."

          # API health
          echo "Checking API..."
          curl -sf https://hummytummy.com/api/health || exit 1

          # Frontend
          echo "Checking frontend..."
          curl -sf https://hummytummy.com || exit 1

          # SSL certificate
          echo "Checking SSL certificate..."
          echo | openssl s_client -servername hummytummy.com -connect hummytummy.com:443 2>/dev/null | \
            openssl x509 -noout -dates || exit 1

          echo "All verification checks passed!"

      - name: Performance check
        run: |
          echo "Checking response times..."

          start=$(date +%s%3N)
          curl -sf https://hummytummy.com/api/health > /dev/null
          end=$(date +%s%3N)

          response_time=$((end - start))
          echo "API response time: ${response_time}ms"

          if [ $response_time -gt 5000 ]; then
            echo "Warning: Response time is high (${response_time}ms)"
          else
            echo "Response time is good (${response_time}ms)"
          fi
